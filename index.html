<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grand Luxury Christmas Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000000;
        font-family: 'Playfair Display', 'Times New Roman', serif;
      }
      canvas {
        display: block;
      }
      /* Hide the webcam video element but keep it functional */
      #webcam-video {
        position: absolute;
        top: 0;
        left: 0;
        opacity: 0;
        pointer-events: none;
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <video id="webcam-video" autoplay playsinline></video>
    
    <!-- Loading Screen -->
    <div id="loading-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-black transition-opacity duration-1000">
      <div class="w-16 h-16 border border-yellow-600/20 border-t-yellow-600 rounded-full animate-spin mb-8"></div>
      <div class="text-yellow-600 text-sm tracking-widest uppercase font-light animate-pulse">
        Constructing Holiday Magic
      </div>
    </div>

    <!-- Main UI -->
    <div id="main-ui" class="absolute inset-0 z-10 pointer-events-none flex flex-col items-center justify-between py-12" style="display: none;">
      <!-- Header -->
      <div class="transition-opacity duration-700">
        <h1 class="text-5xl md:text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-b from-white to-yellow-400 tracking-widest drop-shadow-lg text-center">
          Merry Christmas
        </h1>
        <p class="text-yellow-600/60 text-center text-xs tracking-widest uppercase mt-4">
          Luxury Edition
        </p>
      </div>

      <!-- Controls -->
      <div class="pointer-events-auto flex flex-col items-center gap-4">
        <label class="
          relative cursor-pointer 
          flex items-center gap-3 
          px-8 py-3 
          bg-black/40 backdrop-blur-md 
          border border-yellow-600/40 
          text-yellow-600 
          uppercase tracking-widest text-xs font-bold
          transition-all duration-300
          hover:bg-yellow-600 hover:text-black hover:shadow-lg
        ">
          <span>ðŸ“·</span>
          <span>Add Memories</span>
          <input 
            type="file" 
            multiple 
            accept="image/*" 
            class="hidden" 
            id="file-input"
          />
        </label>

        <div class="text-yellow-600/40 text-xs tracking-widest uppercase mt-2">
          Click to Interact â€¢ Drag to Rotate
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from 'https://esm.sh/three@^0.182.0';
      import { EffectComposer } from 'https://esm.sh/three@^0.182.0/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://esm.sh/three@^0.182.0/examples/jsm/postprocessing/RenderPass.js';
      import { UnrealBloomPass } from 'https://esm.sh/three@^0.182.0/examples/jsm/postprocessing/UnrealBloomPass.js';
      import { RoomEnvironment } from 'https://esm.sh/three@^0.182.0/examples/jsm/environments/RoomEnvironment.js';

      const CONFIG = {
        colors: {
          bg: 0x000000,
          champagneGold: 0xffd700,
          deepGreen: 0x165b33,
          accentRed: 0xc41230,
        },
        particles: {
          count: 800,
          dustCount: 1000,
          treeHeight: 24,
          treeRadius: 8,
        },
        camera: {
          z: 50,
        },
      };

      class Particle {
        constructor(mesh, type, isDust = false) {
          this.mesh = mesh;
          this.type = type;
          this.isDust = isDust;
          this.id = Math.random();

          this.posTree = new THREE.Vector3();
          this.posScatter = new THREE.Vector3();
          this.baseScale = mesh.scale.x;

          const speedMult = type === 'PHOTO' ? 0.3 : 2.0;
          this.spinSpeed = new THREE.Vector3(
            (Math.random() - 0.5) * speedMult,
            (Math.random() - 0.5) * speedMult,
            (Math.random() - 0.5) * speedMult
          );

          this.calculatePositions();
        }

        calculatePositions() {
          // Tree shape
          const h = CONFIG.particles.treeHeight;
          const halfH = h / 2;
          let t = Math.random();
          t = Math.pow(t, 0.8);
          const y = t * h - halfH;
          let rMax = CONFIG.particles.treeRadius * (1.0 - t);
          if (rMax < 0.5) rMax = 0.5;
          const angle = t * 50 * Math.PI + Math.random() * Math.PI;
          const r = rMax * (0.8 + Math.random() * 0.4);
          this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);

          // Scatter shape
          let rScatter = this.isDust ? 15 + Math.random() * 25 : 10 + Math.random() * 15;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          this.posScatter.set(
            rScatter * Math.sin(phi) * Math.cos(theta),
            rScatter * Math.sin(phi) * Math.sin(theta),
            rScatter * Math.cos(phi)
          );
        }

        update(dt, mode, time) {
          let target = mode === 'SCATTER' ? this.posScatter : this.posTree;
          
          const lerpSpeed = 1.8;
          this.mesh.position.lerp(target, lerpSpeed * dt);

          if (mode === 'SCATTER') {
            this.mesh.rotation.x += this.spinSpeed.x * dt;
            this.mesh.rotation.y += this.spinSpeed.y * dt;
            this.mesh.rotation.z += this.spinSpeed.z * dt;
          } else {
            this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
            this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
            this.mesh.rotation.y += 0.5 * dt;
          }

          let s = this.baseScale;
          if (this.isDust) {
            s = this.baseScale * (0.8 + 0.5 * Math.sin(time * 3 + this.id * 10));
            if (mode === 'TREE') s = 0;
          } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
            s = this.baseScale * 2.0;
          }

          this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 3.0 * dt);
        }
      }

      // Initialize scene
      let mode = 'TREE';
      let particles = [];
      let mainGroup;
      let photoGroup;
      let mouse = { x: 0, y: 0 };

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.colors.bg);
      scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.015);

      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, CONFIG.camera.z);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: 'high-performance',
        stencil: false,
        depth: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;

      document.getElementById('root').appendChild(renderer.domElement);

      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);

      mainGroup = new THREE.Group();
      scene.add(mainGroup);

      const innerLight = new THREE.PointLight(0xffaa00, 3, 25);
      innerLight.position.set(0, 5, 0);
      mainGroup.add(innerLight);

      const spotGold = new THREE.SpotLight(0xffcc66, 1500);
      spotGold.position.set(30, 40, 40);
      spotGold.angle = 0.5;
      spotGold.penumbra = 0.5;
      scene.add(spotGold);

      // Create particles
      photoGroup = new THREE.Group();
      mainGroup.add(photoGroup);

      // Geometries and materials
      const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);

      const goldMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.champagneGold,
        metalness: 1.0,
        roughness: 0.15,
        envMapIntensity: 2.5,
        emissive: 0x442200,
        emissiveIntensity: 0.2,
      });

      const greenMat = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.deepGreen,
        metalness: 0.0,
        roughness: 0.9,
      });

      const redMat = new THREE.MeshPhysicalMaterial({
        color: CONFIG.colors.accentRed,
        metalness: 0.1,
        roughness: 0.1,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        emissive: 0x330000,
        emissiveIntensity: 0.1
      });

      // Generate particles
      for (let i = 0; i < CONFIG.particles.count; i++) {
        const rand = Math.random();
        let mesh, type;
        if (rand < 0.4) {
          mesh = new THREE.Mesh(boxGeo, greenMat);
          type = 'BOX';
        } else if (rand < 0.7) {
          mesh = new THREE.Mesh(boxGeo, goldMat);
          type = 'GOLD_BOX';
        } else if (rand < 0.92) {
          mesh = new THREE.Mesh(sphereGeo, goldMat);
          type = 'GOLD_SPHERE';
        } else {
          mesh = new THREE.Mesh(sphereGeo, redMat);
          type = 'RED';
        }

        const s = 0.4 + Math.random() * 0.5;
        mesh.scale.set(s, s, s);
        mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
        mainGroup.add(mesh);
        particles.push(new Particle(mesh, type, false));
      }

      // Dust particles
      const dustGeo = new THREE.TetrahedronGeometry(0.08, 0);
      const dustMat = new THREE.MeshBasicMaterial({ color: 0xffeebb, transparent: true, opacity: 0.6 });
      for (let i = 0; i < CONFIG.particles.dustCount; i++) {
        const mesh = new THREE.Mesh(dustGeo, dustMat);
        mesh.scale.setScalar(0.5 + Math.random());
        mainGroup.add(mesh);
        particles.push(new Particle(mesh, 'DUST', true));
      }

      // Star
      const createStarShape = (outerRadius, innerRadius, points) => {
        const shape = new THREE.Shape();
        const step = Math.PI / points;
        shape.moveTo(0, outerRadius);
        for(let i = 0; i < 2 * points; i++) {
          const r = (i % 2 === 0) ? outerRadius : innerRadius;
          const a = i * step;
          shape.lineTo(Math.sin(a) * r, Math.cos(a) * r);
        }
        shape.closePath();
        return shape;
      };

      const starShape = createStarShape(1.8, 0.9, 5);
      const starGeo = new THREE.ExtrudeGeometry(starShape, {
        depth: 0.4,
        bevelEnabled: true,
        bevelThickness: 0.1,
        bevelSize: 0.1,
        bevelSegments: 2
      });
      starGeo.center();

      const starMat = new THREE.MeshStandardMaterial({
        color: 0xffdd88,
        emissive: 0xffaa00,
        emissiveIntensity: 2.0, 
        metalness: 1.0,
        roughness: 0,
      });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
      star.rotation.y = Math.PI / 4; 
      mainGroup.add(star);

      // Post processing
      const renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      bloomPass.threshold = 0.5; 
      bloomPass.strength = 0.6;  
      bloomPass.radius = 0.8;    

      const composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      const clock = new THREE.Clock();

      // Animation loop
      const animate = () => {
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();

        const targetY = mouse.x * Math.PI * 0.5; 
        const targetX = mouse.y * Math.PI * 0.2;

        if (mode === 'TREE') {
          mainGroup.rotation.y += 0.2 * dt;
          mainGroup.rotation.x += (targetX - mainGroup.rotation.x) * 2.0 * dt;
        } else {
          mainGroup.rotation.y += (targetY - mainGroup.rotation.y) * 2.0 * dt;
          mainGroup.rotation.x += (targetX - mainGroup.rotation.x) * 2.0 * dt;
        }

        star.rotation.y += 0.5 * dt;

        particles.forEach(p => p.update(dt, mode, time));

        composer.render();
        requestAnimationFrame(animate);
      };

      // Event listeners
      const handleResize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      };

      const onMouseMove = (e) => {
        mouse = {
          x: (e.clientX / window.innerWidth) * 2 - 1,
          y: -(e.clientY / window.innerHeight) * 2 + 1
        };
      };

      const onClick = () => {
        mode = mode === 'TREE' ? 'SCATTER' : 'TREE';
      };

      window.addEventListener('resize', handleResize);
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('click', onClick);

      // Start animation
      requestAnimationFrame(animate);
      
      // Hide loading screen after delay
      setTimeout(() => {
        document.getElementById('loading-screen').style.display = 'none';
        document.getElementById('main-ui').style.display = 'flex';
      }, 2000);

      // File upload handler
      document.getElementById('file-input').addEventListener('change', (e) => {
        if (e.target.files && e.target.files.length > 0) {
          Array.from(e.target.files).forEach((file) => {
            const reader = new FileReader();
            reader.onload = (ev) => {
              if (ev.target?.result) {
                new THREE.TextureLoader().load(ev.target.result, (tex) => {
                  tex.colorSpace = THREE.SRGBColorSpace;
                  
                  // Create photo frame
                  const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
                  const frameMat = new THREE.MeshStandardMaterial({
                    color: CONFIG.colors.champagneGold,
                    metalness: 1.0,
                    roughness: 0.15,
                    envMapIntensity: 2.0
                  });
                  const frame = new THREE.Mesh(frameGeo, frameMat);

                  const photoGeo = new THREE.PlaneGeometry(1.2, 1.2);
                  const photoMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                  const photo = new THREE.Mesh(photoGeo, photoMat);
                  photo.position.z = 0.04;

                  const group = new THREE.Group();
                  group.add(frame);
                  group.add(photo);

                  const s = 0.8;
                  group.scale.set(s, s, s);

                  photoGroup.add(group);
                  
                  const p = new Particle(group, 'PHOTO', false);
                  group.position.copy(p.posScatter);
                  particles.push(p);
                });
              }
            };
            reader.readAsDataURL(file);
          });
        }
      });
    </script>
  </body>
</html>
